include "../../../arch/x64/X64.Vale.InsBasic.vaf"
include {:fstar}{:open} "Arch.TypesNative"
include {:fstar}{:open} "Util.Meta"

module X64.Cpuid

#verbatim{:interface}{:implementation}
open Types_s
open Arch.Types
open X64.Machine_s
open X64.Memory
open X64.Vale.State
open X64.Vale.Decls
open X64.Vale.InsBasic
open X64.Vale.QuickCode
open X64.Vale.QuickCodes
open X64.CPU_Features_s

//let pow2_values (u:unit) : Lemma 
//  (pow2 29 == 0x20000000 /\
//   pow2 25 == 0x2000000 /\
//   pow2  1 == 0x2)
//  = 
//  assert_norm (pow2 29 == 0x20000000);
//  assert_norm (0x2000000 == pow2 25);
//  assert_norm (0x2 == pow2 1);
//  ()
#endverbatim

#verbatim{:implementation}
open Util.Meta
#endverbatim

procedure{:public}{:quick} check_aesni_support()
    modifies rax; rbx; rcx; rdx; r9; efl;
    ensures rax != 0 ==> aesni_enabled && pclmulqdq_enabled;
            rbx == old(rbx);
{
    Mov64(r9, rbx);     // Callee-save

    Mov64(rax, 1);
    Cpuid_AES();
    lemma_iand_pow2_64(rcx, 25); // ==> rcx & pow2(25) == 0 or pow2(25)
    lemma_iand_pow2_64(rcx, 1);  // ==> rcx & pow2( 1) == 0 or pow2(1)
    Mov64(rax, rcx);
    And64(rax, 0x2000000);
    Util.Meta.assert_norm(0x2000000 == pow2(25));
    Util.Meta.assert_norm(0x2 == pow2(1));
    
    Shr64(rax, 24);
    lemma_ishr_pow2_diff64(1, 25); // ==> shr(pow2(25), 24) == pow2(1)
    lemma_ishr_zero64(24);         // ==> shr(0, 24) == 0

    And64(rcx, 0x2);
    lemma_iand_maybe_pow2_64(rax, rcx, 1); // Post condition
    And64(rax, rcx);
//    assert rax != 0 ==> pclmulqdq_enabled;
//    assert rax != 0 ==> aesni_enabled;
//    assert !aesni_enabled ==> rax == 0;
//    assert !pclmulqdq_enabled ==> rax == 0;

    Mov64(rbx, r9);     // Callee-restore
}

procedure{:public}{:quick} check_sha_support()
    modifies rax; rbx; rcx; rdx; r9; efl;
    ensures rax != 0 ==> sha_enabled;
            rbx == old(rbx);

{
    Mov64(r9, rbx);     // Callee-save

    Mov64(rax, 7);
    Mov64(rcx, 0);
    Cpuid_Sha();
    lemma_iand_pow2_64(rbx, 29); 
    And64(rbx,0x20000000);
    Util.Meta.assert_norm(0x20000000 == pow2(29));
    Mov64(rax, rbx);

    Mov64(rbx, r9);     // Callee-restore
}


procedure{:public}{:quick} check_adx_bmi2_support()
    modifies rax; rbx; rcx; rdx; r9; efl;
    ensures rax != 0 ==> adx_enabled && bmi2_enabled;
            rbx == old(rbx);

{
    Mov64(r9, rbx);     // Callee-save

    Mov64(rax, 7);
    Mov64(rcx, 0);
    Cpuid_Adx_Bmi2();
    lemma_iand_pow2_64(rbx, 8); 
    lemma_iand_pow2_64(rbx, 19); 
    Mov64(rax, rbx);    // Save a copy

    And64(rax, 0x80000);

    Util.Meta.assert_norm(0x100 == pow2(8));
    Util.Meta.assert_norm(0x80000 == pow2(19));
    
    Shr64(rax, 11);
    lemma_ishr_pow2_diff64(8, 19); // ==> shr(pow2(19), 11) == pow2(8)
    lemma_ishr_zero64(11);         // ==> shr(0, 11) == 0

    And64(rbx, 0x100);
    lemma_iand_maybe_pow2_64(rax, rbx, 8); // Post condition
    And64(rax, rbx);

    Mov64(rbx, r9);     // Callee-restore
}

procedure{:public}{:quick} check_avx_support()
    modifies rax; rbx; rcx; rdx; r9; efl;
    ensures rax != 0 ==> avx_enabled;
            rbx == old(rbx);

{
    Mov64(r9, rbx);     // Callee-save

    Mov64(rax, 1);
    Cpuid_Avx();
    lemma_iand_pow2_64(rcx, 25); // ==> rcx & pow2(25) == 0 or pow2(25)
    Mov64(rax, rcx);
    And64(rax, 0x10000000);
    Util.Meta.assert_norm(0x10000000 == pow2(28));
    
    Shr64(rax, 27);
    lemma_ishr_pow2_diff64(1, 28); // ==> shr(pow2(25), 24) == pow2(1)
    lemma_ishr_zero64(27);         // ==> shr(0, 24) == 0

    Mov64(rbx, r9);     // Callee-restore
}

procedure{:public}{:quick} check_avx2_support()
    modifies rax; rbx; rcx; rdx; r9; efl;
    ensures rax != 0 ==> avx2_enabled;
            rbx == old(rbx);

{
    Mov64(r9, rbx);     // Callee-save

    Mov64(rax, 7);
    Mov64(rcx, 0);
    Cpuid_Avx2();
    lemma_iand_pow2_64(rbx, 5); 
    And64(rbx,0x20);
    Util.Meta.assert_norm(0x20 == pow2(5));
    Mov64(rax, rbx);

    Mov64(rbx, r9);     // Callee-restore
}