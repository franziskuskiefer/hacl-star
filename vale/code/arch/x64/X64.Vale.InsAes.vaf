include "X64.Vale.InsBasic.vaf"
include "X64.Vale.InsVector.vaf"
include{:fstar}{:open} "Words_s"
include{:fstar}{:open} "Types_s"
include{:fstar}{:open} "Arch.Types"
include{:fstar}{:open} "AES_s"
include{:fstar}{:open} "Math.Poly2_s"
include{:fstar}{:open} "Math.Poly2.Bits_s"
include{:fstar}{:open} "X64.Machine_s"
include{:fstar}{:open} "X64.Vale.State"
include{:fstar}{:open} "X64.Vale.Decls"
include{:fstar}{:open} "X64.Vale.QuickCode"
include{:fstar}{:open} "X64.CPU_Features_s"

module X64.Vale.InsAes

#verbatim{:interface}
open Words_s
open Types_s
open Arch.Types
open AES_s
open Math.Poly2_s
open Math.Poly2.Bits_s
open X64.Machine_s
open X64.Vale.State
open X64.Vale.Decls
open X64.Vale.QuickCode
open X64.CPU_Features_s
#endverbatim

#verbatim
open Types_s
open X64.Machine_s
open X64.Vale
open X64.Vale.State
open X64.Vale.StateLemmas
open X64.Vale.Decls
open X64.CPU_Features_s
module S = X64.Bytes_Semantics_s
module TS = X64.Taint_Semantics_s
module P = X64.Print_s

friend X64.Vale.StateLemmas
friend X64.Vale.Decls
#reset-options "--initial_fuel 2 --max_fuel 2 --z3rlimit 20"
#endverbatim

procedure{:quick exportOnly}{:public}
    {:instruction Ins(TS.TaintedIns(tuple(S.Pclmulqdq(dst, src, (if dstHi then 1 else 0) + (if srcHi then 16 else 0))), Public))}
    Pclmulqdq(inout dst:xmm, src:xmm, inline dstHi:bool, inline srcHi:bool)
    requires pclmulqdq_enabled;
    modifies efl;
    ensures
        dst == old(to_quad32(mul(
            of_double32(if dstHi then quad32_double_hi(dst) else quad32_double_lo(dst)),
            of_double32(if srcHi then quad32_double_hi(src) else quad32_double_lo(src)))));
{
}

procedure{:quick exportOnly}{:public}
    {:instruction Ins(TS.TaintedIns(tuple(S.VPclmulqdq(dst, src1, src2, (if src1Hi then 1 else 0) + (if src2Hi then 16 else 0))), Public))}
    VPclmulqdq(out dst:xmm, src1:xmm, src2:xmm, inline src1Hi:bool, inline src2Hi:bool)
    requires pclmulqdq_enabled;
    modifies efl;
    ensures
        dst == old(to_quad32(mul(
            of_double32(if src1Hi then quad32_double_hi(src1) else quad32_double_lo(src1)),
            of_double32(if src2Hi then quad32_double_hi(src2) else quad32_double_lo(src2)))));
{
}

procedure{:instruction Ins(TS.TaintedIns(tuple(S.AESNI_enc(dst, src)), Public))}{:quick exportOnly}{:public}
    AESNI_enc(inout dst:xmm, src:xmm)
    requires aesni_enabled;
    modifies efl;
    ensures
        dst == old(quad32_xor(mix_columns_LE(sub_bytes(shift_rows_LE(dst))), src));
{
}

procedure{:instruction Ins(TS.TaintedIns(tuple(S.VAESNI_enc(dst, src1, src2)), Public))}{:quick exportOnly}{:public}
    VAESNI_enc(inout dst:xmm, src1:xmm, src2:xmm)
    requires aesni_enabled;
    modifies efl;
    ensures
        dst == old(quad32_xor(mix_columns_LE(sub_bytes(shift_rows_LE(src1))), src2));
{
}

procedure{:instruction Ins(TS.TaintedIns(tuple(S.AESNI_enc_last(dst, src)), Public))}{:quick exportOnly}{:public}
    AESNI_enc_last(inout dst:xmm, src:xmm)
    requires aesni_enabled;
    modifies efl;
    ensures
        dst == old(quad32_xor(sub_bytes(shift_rows_LE(dst)), src));
{
}

procedure{:instruction Ins(TS.TaintedIns(tuple(S.VAESNI_enc_last(dst, src1, src2)), Public))}{:quick exportOnly}{:public}
    VAESNI_enc_last(inout dst:xmm, src1:xmm, src2:xmm)
    requires aesni_enabled;
    modifies efl;
    ensures
        dst == old(quad32_xor(sub_bytes(shift_rows_LE(src1)), src2));
{
}

procedure{:instruction Ins(TS.TaintedIns(tuple(S.AESNI_dec(dst, src)), Public))}{:quick exportOnly}
    AESNI_dec(inout dst:xmm, src:xmm)
    requires aesni_enabled;
    modifies efl;
    ensures
        dst == old(quad32_xor(inv_mix_columns_LE(inv_sub_bytes(inv_shift_rows_LE(dst))), src));
{
}

procedure{:instruction Ins(TS.TaintedIns(tuple(S.AESNI_dec_last(dst, src)), Public))}{:quick exportOnly}
    AESNI_dec_last(inout dst:xmm, src:xmm)
    requires aesni_enabled;
    modifies efl;
    ensures
        dst == old(quad32_xor(inv_sub_bytes(inv_shift_rows_LE(dst)), src));
{
}

procedure{:instruction Ins(TS.TaintedIns(tuple(S.AESNI_imc(dst, src)), Public))}{:quick exportOnly}
    AESNI_imc(inout dst:xmm, src:xmm)
    requires aesni_enabled;
    modifies efl;
    ensures
        dst == old(inv_mix_columns_LE(src));
{
}

procedure{:instruction Ins(TS.TaintedIns(tuple(S.AESNI_keygen_assist(dst, src, imm)), Public))}{:quick exportOnly}{:public}
    AESNI_keygen_assist(inout dst:xmm, src:xmm, inline imm:imm8)
    requires aesni_enabled;
    modifies efl;
    ensures
        dst == old(Mkfour(
            sub_word(src.lo1),
            ixor32(rot_word_LE(sub_word(src.lo1)), imm),
            sub_word(src.hi3),
            ixor32(rot_word_LE(sub_word(src.hi3)), imm)));
{
}

